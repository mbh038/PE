\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{amsmath}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{Brief Article}
\author{The Author}
%\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle
\section{Problems}
\subsection{Problem 50} \textbf{Consecutive prime sum}

Python, about 35 ms.
I start with sums of primes from 2, and find the longest sequence of primes that sum to a prime, then do the same from 3, and stop once it is not possible to find a sequence longer than the longest already found, which starts from 7.

I use a 3.5x faster version of David Epstein's very nice primes generator, and a simple 6n±1 test for primality that I have used on other problems.
\begin{verbatim}
import time
import numpy as np
import itertools as it
           
def cp(n):
    t = time.clock()
    nmoretries=1000
    ntries=0
    for startFrom in list(primesieve(100)):
        ntries+=1
        if ntries>nmoretries:
            break
        psums={}
        psums[startFrom],count,countmax=0,0,-1
        for p in erat2a():
            if p<startFrom:
                continue
            count+=1         
            psums[startFrom]+=p
            if psums[startFrom]>n:
                break
            if isPrime(psums[startFrom]):
                if count>countmax:
                    pmax=p
                    nmax=psums[startFrom]
                    countmax=count
        print (startFrom,pmax,nmax,countmax)
        
        # is it worth continuing?
        if primesthatsumto(n)-countmax<nmoretries:
            nmoretries=primesthatsumto(n)-countmax
            ntries=0
    print(time.clock()-t)

def primesthatsumto(n):
    psum=0
    count=0
    for p in erat2a():
        psum+=p
        if psum>n:
            break
        count+=1
    return count
#  
# prime generator
#http://code.activestate.com/recipes/117119/
def erat2a():
    D = {}
    yield 2
    for q in it.islice(it.count(3), 0, None, 2):
        p = D.pop(q, None)
        if p is None:
            D[q * q] = 2 * q # use here 2 * q
            yield q
        else:
            x = p + q
            while x in D:
                x += p
            D[x] = p
            
def primesieve(n):
    """return array of primes 2<=p<=n"""
    sieve=np.ones(n+1,dtype=bool)
    for i in range(2, int((n+1)**0.5+1)):
        if sieve[i]:
            sieve[2*i::i]=False
    return np.nonzero(sieve)[0][2:]
    
def isPrime(n):
    """Returns True if n is prime."""
    if n==2 or n==3:
        return True
    if not n%2 or not n%3:
        return False
    i = 5
    w = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += w
        w = 6 - w
    return True
\end{verbatim}

\subsection{Problem 60} \textbf{Prime pair sets}

Bah! I cannot get this to go any quicker than about 3.6 s. At least that is way faster than the 120 s+ I was getting when I first solved this.

I  first generate a dictionary of primes $p_i$ up to some limit, then to each of these I attach a set of the other primes in that dict, $p_j$, for which the concatenations $p_ip_j$ and $p_jp_i$ are prime. I then use set intersections to find the primes that connect to however many others is required. 

Creating the dictionary takes 90\% of the total time.

Creating primes is far faster than checking for primality - so if checking is what you want to do, then it can be faster to put lots of primes in a data structure with constant look-up time, such as a Python set or dictionary, then check whether your candidate prime is in that structure.

This problem is clearly amenable to graph-theoretical analysis, and what I have done resembles looking for cliques in a graph. I look forward to pursuing this more explicitly.

\begin{verbatim}
def primesfrom2to(n):
    """ Input n>=6, Returns a array of primes, 2 <= p < n """
    #Code by Robert William Hanks
    #http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n/3035188#3035188
    sieve = numpy.ones(n//3 + (n%6==2), dtype=numpy.bool)
    for i in range(1,int(n**0.5/3)+1):
        if sieve[i]:
            k=3*i+1|1
            sieve[       k*k//3   ::2*k] = False
            sieve[k*(k-2*(i&1)+4)//3::2*k] = False
    return numpy.r_[2,3,((3*numpy.nonzero(sieve)[0][1:]+1)|1)]    

def goodprimes(n,m):
    primes=list(primesfrom2to(n))
    pc=set(primesfrom2to(n**2))
    [x.remove(y) for x in [primes,pc] for y in [2,5]]    
    pdic={prime:set([prime]) for prime in primes}
    for prime1 in primes:
        for prime2 in primes:
            try1=prime1*10**(int(math.log10(prime2))+1)+prime2
            if try1 not in pc:
                continue
            try2=prime2*10**(int(math.log10(prime1))+1)+prime1
            if try2 in pc:
                pdic[prime1].add(prime2)
    opdic={}
    for k,v in pdic.items():
        if len (v)>=m:
            opdic[k]=v 
    return opdic,pc
          
def PE_0060(n,m):
    
    start1=timer()    
    pdic,pc=goodprimes(n,m)
    print ('Elapsed time:',timer()-start1)
    
    start2=timer()
    smin=math.inf
    tts={}
    for k,v in pdic.items():
        for x in v:
            if x ==k: continue
            try:
                tt=v.intersection(pdic[x])
                tts.setdefault(len(tt),[]).append(tt)
            except:
                pass          
    print ('Elapsed time:',timer()-start2)
    
    start3=timer()
    for tt in tts[m]:
       if sum([x*10**(int(math.log10(y))+1)+y in pc for x in tt for y in tt if x!=y ])==m*(m-1):
            if sum(tt)<smin:
                smin=sum(tt)
                ttmin=tt
    print(ttmin,smin)      
    print ('Elapsed time:',timer()-start3)
    
    print ('Total elapsed time:',timer()-start1)
\end{verbatim}

\subsection{Problem 64}\textbf{Odd period square roots}

About 240 ms in Python

\begin{verbatim}
import time
import math
def p64(n):
    """returns number of  integers <=n that have odd-period continued fractions""" 
    t=time.clock()
    c=0
    for i in range (1,n+1):
        if  i%4==0 or int(math.sqrt(i))==math.sqrt(i):
            continue
        if len(sqcf(i)[1])%2==1:
            c+=1           
    print (c,time.clock()-t)
    
def sqcf(S):
    """
    S is a natural number. Must not be a perfect square
    
    returns (a0,[r0,..,rn]) where a0 is the stem and [r0,...,rn] is the 
    repeating part of the square root continued fraction of S
    """
    a=[int(math.sqrt(S))]    
    d0,d=1,1
    m=0      
    while 1:
        m=d*a[-1]-m
        d=int((S-m**2)/d)
        a.append(int((a[0]+m)/d))
        if d==d0:
            return (a[0],a[1:])
            break
\end{verbatim}

\subsection{Problem 74} \textbf{Digit factorial chains}

About 50 ms*, in Python.

I only check for numbers with integers that increase in order, then find the number of valid permutations of those digits - all permutations must have the same chain length. To speed things up when working through chains, I develop a dictionary of the chain lengths found for all numbers that have appeared in chains before, and stop when I get to one of these numbers, because the chain length of the present number can now be calculated directly. This saves a lot of time.

When I first solved the problem using brute force, my code required 70 s. Getting the dictionary/cache method to work correctly (which took me ages!) brought that down by a factor of 20 to 3.5 s, then the realisation that digit order did not matter brought the time down by a further factor of 70, to 50 ms.

\begin{verbatim}
def p74(n):
    start=timer()
    fs=[1,1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    chainlengths={169:3,871:2,872:2,145:1,69:5,78:4,540:2}
    fd=set()    
    for number in itertools.combinations_with_replacement('0123456789',len(str(n-1))):
        nx=int(''.join([x for x in number]))
        for number in [nx,10*nx]:
            if number>n:
                continue
            chain=[number]
            while 1:
                candidate=sum([fs[int(x)] for x in str(chain[-1])])
                if candidate in set(chain):
                    chainlengths[candidate]=len(chain)-chain.index(candidate)
                    break
                if candidate in chainlengths:
                    chainlengths[number]=len(chain)+chainlengths[candidate]
                    break
                chain.append(candidate)
    
            for j in range(len(chain)):
                if chain[j] in chainlengths:
                    continue
                if candidate in set(chain):
                    chainlengths[chain[j]]=chainlengths[candidate]+chain.index(candidate)-j
                else:
                    chainlengths[chain[j]]=chainlengths[candidate]+len(chain)-j
    
            if chainlengths[number]==60:
                fd.add(number)

    #how many permutations are there of each of these numbers?
    ysum=[]
    for x in fd:
        y=[i for i in str(x)]
        ysum.append(math.factorial(len(y)))
        if '0' in y:
            ysum[-1]-=math.factorial(len(y)-1)
        y=''.join([i for i in y])
        xdic={}
        for digit in y:
            xdic[digit]=xdic.get(digit,0)+1
        for k,v in xdic.items()]
            ysum[-1]=ysum[-1]//math.factorial(v)          
        
    print(sum(ysum))       
    print('Elapsed time',timer()-start)
\end{verbatim}

\subsection{Problem 75}\textbf{Singular integer right triangles}


Feels slow - about 4 s in Python.

I use the three generating matrices to generate a ternary tree of primitive triads, then add in the non-primitives. Nothing more clever going on.

\begin{verbatim}
import numpy as np
import copy

def perimeters(n,m):

   print('Up to a maximum perimeter of',n,'there are:')
   L=primitives(n)
   allL(n,L,m)

def primitives(n):
    """
    returns dictionary L {k:v} where k are the perimeters of primitive
    Pythagorean triangles less than n, and v are the number primitives that share
    that perimeter
    """

    #generating matrices
    A = np.array( [[1,-2,2], [2,-1,2],[2,-2,3]] )
    B = np.array( [[1,2,2], [2,1,2],[2,2,3]] )
    C = np.array( [[-1,2,2], [-2,1,2],[-2,2,3]] )
    
    L={12:1}
    tripgen=[[3,4,5]]  # the root of the tree   
    
    while True:
        nextgen=[]
        for triplet in tripgen:
            for matrix in [A,B,C]:
                c=np.dot(matrix,np.array(triplet))                
                if c[2]<=n/2:
                    length=sum(c)
                    nextgen.append(list(c))
                    L[length]=L.get(length,0)+1
        if len(nextgen)==0:
            break
        tripgen=copy.deepcopy(nextgen)
    p=(sum([y for x,y in L.items() if x<=n and y>=1]))
    print(p,'primitive Pythagorean trangles') 
    return L
    

def allL(n,L,m):
    """
    returns the number of perimeters less than n shared by m Pythagorean triangles
    L is a dict of primitive perimeters returned by primitives()
    """
    AllPT={}
    for primitive,v in L.items():
        length=0
        i=0
        while True:
            i+=1
            length=i*primitive
            if length>n:
                break
            AllPT[length]=AllPT.get(length,0)+1
    perims= (len({x:y for x,y in AllPT.items() if x<=n and y==m}))
    print(perims,'perimeters common to',m,'Pythagorean triangles')    
\end{verbatim}

\subsection{Problem 94} \textbf{Almost equilateral triangles}

More Pythagorean triples, where this time we need only consider primitive triples. About 1.3 ms in Python.

\begin{verbatim}
import numpy as np

def aet(pmax):
    """
    returns L, a dictionary of all the right-angle triangles a<b<c that, when 
    mirrored on b, give an almost-equilateral triangle (c,c,2a) where 2a=c+/-1,
    with perimeter less than or equal to pmax. These almost-equilateral triangles
    necessarily comprise the set of those that have integer area.
    """
    #generating matrices
    A = np.array( [[1,-2,2], [2,-1,2],[2,-2,3]] )
    B = np.array( [[1,2,2], [2,1,2],[2,2,3]] )
    C = np.array( [[-1,2,2], [-2,1,2],[-2,2,3]] )
       
    tripgen=[[3,4,5]]
    L={5:[3,4,5]}
        
    while True:
        nextgen=[]
        for triplet in tripgen:
            for matrix in [A,B,C]:
                c=sorted(list(np.dot(matrix,np.array(triplet))))
                if 2*(c[0]+c[2])<=pmax:
                    if c[0]==(c[2]+1)/2 or c[0]==(c[2]-1)/2:
                        nextgen.append(c)
                        L[c[2]]=c

        if len(nextgen)==0:
            break
        tripgen=nextgen[:]

    print(sum([2*(v[0]+v[2]) for k,v in L.items()]))
    return L
\end{verbatim}

\subsection{Problem 114}

$50-100 \mu\text{s}$ in Python, using recursion and a memo. For block lengths up to 3 units I worked out the number of solutions that had a red left-most block, or a black left-most block, and put these pairs of values in a dictionary with the block length as key. Then, working upwards in block lengths one unit at a time, I imagined placing $k=1$ to $n$ black blocks at  the left-most end. For each value $k$, this  gave a rightward space of $n-k$ blocks in length that had to be filled with  any allowed combination of sub-blocks that had a red left-most edge. I could look this value up in the dictionary. The sum of these values for each $k$ then gave the number of solutions for blocks of length $n$ with a black left edge. To find the solutions for $n$ units that have a red edge, I do the same, starting this time with a red block of 3 units at the left edge.

In fact, on inspecting the numbers for the first few block lengths, one sees that the recursion relation is:

\begin{align*}
n_{\text{black left edge}}(L)&=n_{\text{black left edge}}(L-1)+n_{\text{red left edge}}(L-1)\\
n_{\text{red left edge}}(L)&=n_{\text{black left edge}}(L-3)+n_{\text{red left edge}}(L-1)
\end{align*}


Here are the values up to $L=20$:

$$
\begin{array}{|r|r|r|r|}\hline
L& R& B& R+B\\\hline
1& 0& 1& 1\\\hline
2& 0& 1& 1 \\\hline
3& 1& 1& 2\\\hline
4& 2& 2& 4\\\hline
5& 3& 4& 7\\\hline
6& 4& 7& 11\\\hline
7& 6& 11& 17\\\hline
8& 10& 17& 27\\\hline
9& 17& 27& 44\\\hline
10& 28& 44& 72\\\hline
11& 45& 72& 117\\\hline
12& 72& 117& 189\\\hline
13& 116& 189& 305\\\hline
14& 188& 305& 493\\\hline
15& 305& 493& 798\\\hline
16& 494& 798& 1292\\\hline
17& 799& 1292& 2091\\\hline
18& 1292& 2091& 3383\\\hline
19& 2090& 3383& 5473\\\hline
20& 3382& 5473& 8855\\\hline
\end{array}
$$


\begin{verbatim}
import time
def F(m,n,memo={}):
    t=time.clock()   
    blocks={k:[0,1] for k in range (1,m)}
    blocks[0]=[0,0]
    blocks[m]=[1,1]
    try:
        print(m,n,memo[(m,n)],time.clock()-t)
        return 
    except KeyError:
        for L in range (m+1,n+1):
            blocks.setdefault(L,[]).append(blocks[L-1][0]+blocks[L-m][1]) #red left-edged solutions
            blocks.setdefault(L,[]).append(blocks[L-1][0]+blocks[L-1][1]) #black left-edged solutions
        result =sum(blocks[L])
        memo[(m,n)]=result
    print(m,n,sum(blocks[L]),time.clock()-t)
\end{verbatim}

\subsection{Problem 243}

About 0.3 ms in Python. I use the same ideas as many here, noting that $R(d)=\frac{\phi(n)}{n-1}\approx \frac{\phi(n)}{n}$ for large $n$, and so is a function only of the prime factors of $n$, independent of the exponents of those factors. The denominator will be minimised if $n$ is a primorial. Thus we look for the smallest primorial number for which $\frac{\phi (n)}{n}< \frac{15499}{94744}$and then multiply that successively by 2 until $\frac{\phi(n)}{n-1}< \frac{15499}{94744}$, knowing that by doing so we will not change the value of $\frac{\phi(n)}{n}$.

\begin{verbatim}
import time
import numpy as np

def p243():
    t=time.clock()
    primes=primesieve(100)
    Rtrial=1
    i=0
    while et(Rtrial)/Rtrial>15499/94744:
        Rtrial*=primes[i]
        i+=1    
    while et(Rtrial)/(Rtrial-1)>15499/94744:
        Rtrial*=2
    print(Rtrial)
    print(time.clock()-t)

def primesieve(n):
    """return array of primes 2<=p<=n"""
    sieve=np.ones(n+1,dtype=bool)
    for i in range(2, int((n+1)**0.5+1)):
        if sieve[i]:
            sieve[2*i::i]=False
    return np.nonzero(sieve)[0][2:]
    
#Euler totient is number of integers m 1 <= m <=n that are coprime with n
def et(n):
    """returns Euler totient (phi) of n """   
    phi=n
    pfs=set(prime_factors(n))
    for pf in pfs:
        phi*=(1-1/pf)
    return int(phi)
       
def prime_factors(n):
    """returns the prime factors of n"""   
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors 
\end{verbatim}

\subsection{Problem 407}
\par
Just meeting the 1000s rule in Python. :( 

But, it is good to be here, at last :)

As of now I cannot see how to speed things up, using this method: I find the prime factors of each $n$, and then, via the Chinese Remainder Theorem, I find one idempotent per prime factor, and then all others as a power set of combinations of these. I couldn't work out how to avoid calculating all $a$ for each $n$.

I note the humbling contributions above, but it has been useful to finally understand how the CRT works and to devise code to implement it.

\begin{verbatim}
import time
import itertools as it

def p407(limit):
    t=time.clock()
    misum=0
    for n in range(2,limit+1):
        misum+=max_idempotent(n)
    print(misum)
    print(time.clock()-t)
    
def max_idempotent(n):
    """returns maximum idempotent a < n: a^2=a mod n"""    
    pfs=pflist(n)
    pfnum=len(pfs)
    if pfnum==1:
        return 1 #idempotent=1 for primes or powers of primes
        
    #Use the CRT to find m 'base' idempotent solutions from m prime factors p_i^a_i   
    idems=[]
    for i in range(pfnum):
        allButOnePfs=pfs[:i]+pfs[i+1:]
        xsum=0
        for i in range(pfnum-1):
            Ni=n//allButOnePfs[i]
            xsum+=inverse(Ni,allButOnePfs[i])*Ni        
        idems.append(xsum % n)

    #generate all other idempotents from these, and return the maximum
    maxval=max(idems)
    for i in range(2,len(idems)):
        for a in it.combinations(idems, i):
            aprod=1
            for x in a:
                aprod*=x
                aprod=aprod%n
            if aprod>maxval:
                maxval=aprod
    return maxval
   
def pflist(n):
    """returns the distinct prime factors of n as [2^a,3^b.....]"""   
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            factors.append(1)
            while not n %i:
                n //= i
                factors[-1]*=i
    if n > 1:
        factors.append(n)
    return factors            
    
#with thanks to Wikipedia and numerous other sources
def inverse(a, n):
    """returns multiplicative inverse of a mod n. a and n must be-co-prime"""
    t1,t2=0,1    
    r1,r2=n,a    
    while r2!=0:
        q = r1 // r2
        t1, t2 = t2, t1 - q * t2
        r1, r2 = r2, r1 - q * r2
    if t1 < 0:
        t1 +=n
    return t1 
\end{verbatim}

\subsection{Problem 512}
 I managed to work out that $\displaystyle g(n) = \sum_{i=1,i \nmid 2}^n \varphi(i)$ and then did the sum by brute-force sieving in 6 minutes.
 
 $$\sum _{i=1}^n \phi \left(n^i\right)=\frac{\left(n^n-1\right) \phi (n)}{n-1}$$
 
 $$(\left(\sum _{i=1}^n \phi \left(n^i\right)\right) \bmod (n+1))=(\left((\frac{n^n-1}{n-1} \bmod (n+1)) (\phi (n) \bmod (n+1))\right) \bmod (n+1))$$
 
 $$(\frac{n^n-1}{n-1} \bmod (n+1))=1$$
 
 Hence
 
 $$\displaystyle g(n) = \sum_{i=1,i \nmid 2}^n \varphi(i)$$

\begin{verbatim}
import numpy as np
import time

def p512(n):
    t=time.clock()
    primes=primesieve(n)
    g=sum(etsieve(n,primes)[1::2])
    print(g,time.clock()-t)

def etsieve(n,primes):
    """return array of euler totient(x) for x from 2 to n"""
    sieve=np.array(range(n+1),dtype=float)
    for i in primes:  
        if sieve[i]==i:
            sieve[i::i]*=(1-1/i)
    return sieve.astype(int)
    
def primesieve(n):
    """return array of primes 2<=p<=n"""
    sieve=np.ones(n+1,dtype=bool)
    for i in range(2, int((n+1)**0.5+1)):
        if sieve[i]:
            sieve[2*i::i]=False
    return np.nonzero(sieve)[0][2:]
\end{verbatim}

To get it within one minute, I had to understand how to sum totients without actually calculating them. This is covered in daniel fischer's excellent overview to problem 73 and in [url=http://math.stackexchange.com/questions/316376/how-to-calculate-these-totient-summation-sums-efficiently.]this stack exchange page[/url] (see the post by 'Andy'), which is also used by the very helpful post earlier in this forum from  chsl95. This code (which is essentially the same as that of chsl95) goes in about 10s.

\begin {verbatim}
def p512v2(n):
    t=time.clock()
    print(oddTotientSum(n))
    print(time.clock()-t)
    
#implements stack exchange 'Andy' 
#http://math.stackexchange.com/questions/316376/how-to-calculate-these-totient-summation-sums-efficiently
def R2(N,X2={}):
    if N==1:
        return 0
    try:
        return X2[N]
    except KeyError:
        fsum = F2(N)
        m=2
        while 1:
            x = N//m
            nxt = N//x
            if(nxt >= N):
                result=fsum - (N-m+1)*R2(N//m,X2)
                X2[N]=result
                return result
            fsum -= (nxt-m+1) * R2(N//m,X2)
            m = nxt+1

#returns sum of totients of x<=n
#wrapper for R2
#sum of totient(x) for x<=n
def totientSum(n):
    return R2(n)+1
    
#sum of totient(x) for x<=n and x is even
def evenTotientSum(N):
    if N < 2:
        return 0
    return totientSum(N//2)+evenTotientSum(N//2)

#sum of totient(x) for x<=n and x is odd (answer to PE p512)    
def oddTotientSum(N):
    return totientSum(N)-evenTotientSum(N)
\end{verbatim}
The key insight I got from chsl95 is how to calculate the sum of totients of even numbers.

\subsection{Problem 613}\textbf{Pythagorean Ant}

I imagined four quadrants, with axes parallel to the triangle sides of length 3 and 4. If the ant walked off in the quadrant facing the hypotenuse it was certain to exit the triangle on that side, and if it walked off towards the right angle, it was certain not to. That left the other two quadrants. For each of these I derived an expression for the probability of exit across the hypotenuse,  to find:


$$P(\text{exit})=\frac{1}{4}\left(1+\frac{2}{\pi}\left(\frac{1}{4} \int^4_0\tan^{-1}\frac{x}{3} dx + \frac{1}{3} \int^3_0\tan^{-1}\frac{x}{4} dx\right)\right)$$

which, with Mathematica's help, I find integrates to:

$$\frac{1}{2}+\frac{-25\log{5}+9\log{3}+32\log{2}}{24\pi}$$

where we use the fact that the two smaller angles of the triangle sum to $\pi/2$.



\end{document}  